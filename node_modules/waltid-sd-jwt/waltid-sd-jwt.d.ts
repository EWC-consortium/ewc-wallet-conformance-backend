type Nullable<T> = T | null | undefined
export declare namespace id.walt.sdjwt {
    abstract class DecoyMode {
        private constructor();
        static get NONE(): id.walt.sdjwt.DecoyMode & {
            get name(): "NONE";
            get ordinal(): 0;
        };
        static get FIXED(): id.walt.sdjwt.DecoyMode & {
            get name(): "FIXED";
            get ordinal(): 1;
        };
        static get RANDOM(): id.walt.sdjwt.DecoyMode & {
            get name(): "RANDOM";
            get ordinal(): 2;
        };
        static values(): Array<id.walt.sdjwt.DecoyMode>;
        static valueOf(value: string): id.walt.sdjwt.DecoyMode;
        get name(): "NONE" | "FIXED" | "RANDOM";
        get ordinal(): 0 | 1 | 2;
    }
}
export declare namespace id.walt.sdjwt {
    interface JWTCryptoProvider {
        sign(payload: any/* kotlinx.serialization.json.JsonObject */, keyID?: Nullable<string>, typ?: string): string;
        verify(jwt: string): id.walt.sdjwt.JwtVerificationResult;
        readonly __doNotUseOrImplementIt: {
            readonly "id.walt.sdjwt.JWTCryptoProvider": unique symbol;
        };
    }
}
export declare namespace id.walt.sdjwt {
    class SDField {
        constructor(sd: boolean, children?: Nullable<any>/* Nullable<id.walt.sdjwt.SDMap> */);
        get sd(): boolean;
        get children(): Nullable<any>/* Nullable<id.walt.sdjwt.SDMap> */;
        copy(sd?: boolean, children?: Nullable<any>/* Nullable<id.walt.sdjwt.SDMap> */): id.walt.sdjwt.SDField;
        toString(): string;
        hashCode(): number;
        equals(other: Nullable<any>): boolean;
    }
}
export declare namespace id.walt.sdjwt {
    class SDJwt {
        private constructor();
        get jwt(): string;
        protected get header(): any/* kotlinx.serialization.json.JsonObject */;
        protected get sdPayload(): id.walt.sdjwt.SDPayload;
        get holderJwt(): Nullable<string>;
        protected get isPresentation(): boolean;
        get zzz_unused_disclosures(): any/* kotlin.collections.Set<string> */;
        get zzz_unused_disclosureObjects(): any/* kotlin.collections.Collection<id.walt.sdjwt.SDisclosure> */;
        get zzz_unused_undisclosedPayload(): any/* kotlinx.serialization.json.JsonObject */;
        get zzz_unused_fullPayload(): any/* kotlinx.serialization.json.JsonObject */;
        get zzz_unused_digestedDisclosures(): any/* kotlin.collections.Map<string, id.walt.sdjwt.SDisclosure> */;
        get zzz_unused_sdMap(): any/* id.walt.sdjwt.SDMap */;
        get algorithm(): Nullable<string>;
        get keyID(): Nullable<string>;
        get jwk(): Nullable<string>;
        toString(): string;
        toFormattedString(formatForPresentation: boolean): string;
        present(sdMap: Nullable<any>/* Nullable<id.walt.sdjwt.SDMap> */, withHolderJwt?: Nullable<string>): id.walt.sdjwt.SDJwt;
        presentAll(discloseAll: boolean, withHolderJwt?: Nullable<string>): id.walt.sdjwt.SDJwt;
        verify(jwtCryptoProvider: id.walt.sdjwt.JWTCryptoProvider): id.walt.sdjwt.VerificationResult<id.walt.sdjwt.SDJwt>;
    }
    namespace SDJwt {
        abstract class Companion extends _objects_.id$walt$sdjwt$SDJwt$Companion {
            private constructor();
        }
        namespace Companion {
            class $signAsyncCOROUTINE$1 /* extends kotlin.coroutines.CoroutineImpl */ {
                constructor(_this_: typeof id.walt.sdjwt.SDJwt.Companion, sdPayload: id.walt.sdjwt.SDPayload, jwtCryptoProvider: any/* id.walt.sdjwt.AsyncJWTCryptoProvider */, keyID: Nullable<string>, withHolderJwt: Nullable<string>, resultContinuation: any/* kotlin.coroutines.Continuation<id.walt.sdjwt.SDJwt> */);
            }
        }
        class $verifyAsyncCOROUTINE$0 /* extends kotlin.coroutines.CoroutineImpl */ {
            constructor(_this_: id.walt.sdjwt.SDJwt, jwtCryptoProvider: any/* id.walt.sdjwt.AsyncJWTCryptoProvider */, resultContinuation: any/* kotlin.coroutines.Continuation<id.walt.sdjwt.VerificationResult<id.walt.sdjwt.SDJwt>> */);
        }
    }
}
declare namespace _objects_ {
    const id$walt$sdjwt$SDJwt$Companion: {
        get DIGESTS_KEY(): string;
        get SEPARATOR(): any/* kotlin.Char */;
        get SEPARATOR_STR(): string;
        get SD_JWT_PATTERN(): string;
        parse(sdJwt: string): id.walt.sdjwt.SDJwt;
        verifyAndParse(sdJwt: string, jwtCryptoProvider: id.walt.sdjwt.JWTCryptoProvider): id.walt.sdjwt.VerificationResult<id.walt.sdjwt.SDJwt>;
        createFromSignedJwt(signedJwt: string, sdPayload: id.walt.sdjwt.SDPayload, withHolderJwt?: Nullable<string>): id.walt.sdjwt.SDJwt;
        sign(sdPayload: id.walt.sdjwt.SDPayload, jwtCryptoProvider: id.walt.sdjwt.JWTCryptoProvider, keyID?: Nullable<string>, withHolderJwt?: Nullable<string>, typ?: string): id.walt.sdjwt.SDJwt;
        isSDJwt(value: string): boolean;
    } & {
        new(): any;
    };
}
export declare namespace id.walt.sdjwt {
    class SDPayload {
        private constructor();
        get undisclosedPayload(): any/* kotlinx.serialization.json.JsonObject */;
        get digestedDisclosures(): any/* kotlin.collections.Map<string, id.walt.sdjwt.SDisclosure> */;
        get sDisclosures(): any/* kotlin.collections.Collection<id.walt.sdjwt.SDisclosure> */;
        get fullPayload(): any/* kotlinx.serialization.json.JsonObject */;
        get sdMap(): any/* id.walt.sdjwt.SDMap */;
        withSelectiveDisclosures(sdMap: any/* kotlin.collections.Map<string, id.walt.sdjwt.SDField> */): id.walt.sdjwt.SDPayload;
        withoutDisclosures(): id.walt.sdjwt.SDPayload;
        verifyDisclosures(): boolean;
        copy(undisclosedPayload?: any/* kotlinx.serialization.json.JsonObject */, digestedDisclosures?: any/* kotlin.collections.Map<string, id.walt.sdjwt.SDisclosure> */): id.walt.sdjwt.SDPayload;
        toString(): string;
        hashCode(): number;
        equals(other: Nullable<any>): boolean;
    }
}
export declare namespace id.walt.sdjwt {
    class SDisclosure {
        private constructor();
        get disclosure(): string;
        get salt(): string;
        get key(): string;
        get value(): any/* kotlinx.serialization.json.JsonElement */;
        copy(disclosure?: string, salt?: string, key?: string, value?: any/* kotlinx.serialization.json.JsonElement */): id.walt.sdjwt.SDisclosure;
        toString(): string;
        hashCode(): number;
        equals(other: Nullable<any>): boolean;
        static get Companion(): {
            parse(disclosure: string): id.walt.sdjwt.SDisclosure;
        };
    }
}
export declare namespace id.walt.sdjwt {
    class JwtVerificationResult {
        constructor(verified: boolean, message?: Nullable<string>);
        get verified(): boolean;
        get message(): Nullable<string>;
        copy(verified?: boolean, message?: Nullable<string>): id.walt.sdjwt.JwtVerificationResult;
        toString(): string;
        hashCode(): number;
        equals(other: Nullable<any>): boolean;
    }
    class VerificationResult<T extends id.walt.sdjwt.SDJwt> {
        constructor(sdJwt: T, signatureVerified: boolean, disclosuresVerified: boolean, message?: Nullable<string>);
        get sdJwt(): T;
        get signatureVerified(): boolean;
        get disclosuresVerified(): boolean;
        get message(): Nullable<string>;
        get verified(): boolean;
        copy(sdJwt?: T, signatureVerified?: boolean, disclosuresVerified?: boolean, message?: Nullable<string>): id.walt.sdjwt.VerificationResult<T>;
        toString(): string;
        hashCode(): number;
        equals(other: Nullable<any>): boolean;
    }
}
export declare namespace id.walt.sdjwt {
    interface JSAsyncJWTCryptoProvider /* extends id.walt.sdjwt.AsyncJWTCryptoProvider */ {
        signAsync(payload: any, keyID: Nullable<string>): Promise<string>;
        verifyAsync(jwt: string): Promise<id.walt.sdjwt.JwtVerificationResult>;
        readonly __doNotUseOrImplementIt: {
            readonly "id.walt.sdjwt.JSAsyncJWTCryptoProvider": unique symbol;
        };
    }
}
export declare namespace id.walt.sdjwt {
    class SDJwtJS extends id.walt.sdjwt.SDJwt {
        constructor(sdJwt: id.walt.sdjwt.SDJwt);
        get disclosures(): Array<string>;
        get disclosureObjects(): Array<any>;
        get undisclosedPayload(): any;
        get fullPayload(): any;
        get sdMap(): any;
        verifyAsync(jwtCryptoProvider: id.walt.sdjwt.JSAsyncJWTCryptoProvider): Promise<id.walt.sdjwt.VerificationResult<id.walt.sdjwt.SDJwtJS>>;
        presentAllAsync(discloseAll: boolean, withHolderJwt?: Nullable<string>): Promise<id.walt.sdjwt.SDJwtJS>;
        presentAsync(sdMap: any, withHolderJwt?: Nullable<string>): Promise<id.walt.sdjwt.SDJwtJS>;
        toFormattedString(formatForPresentation: boolean): string;
        static get Companion(): {
            verifyAndParseAsync(sdJwt: string, jwtCryptoProvider: id.walt.sdjwt.JSAsyncJWTCryptoProvider): Promise<id.walt.sdjwt.VerificationResult<id.walt.sdjwt.SDJwtJS>>;
            signAsync(sdPayload: id.walt.sdjwt.SDPayload, jwtCryptoProvider: id.walt.sdjwt.JSAsyncJWTCryptoProvider, keyID?: Nullable<string>, withHolderJwt?: Nullable<string>): Promise<id.walt.sdjwt.SDJwtJS>;
        };
    }
}
export declare namespace id.walt.sdjwt {
    class SDMapBuilder {
        constructor(decoyMode?: string, numDecoys?: number);
        addField(key: string, sd: boolean, children?: any): id.walt.sdjwt.SDMapBuilder;
        build(): any;
        buildFromJsonPaths(jsonPaths: Array<string>): any;
    }
}
export declare namespace id.walt.sdjwt {
    class SDPayloadBuilder {
        constructor(fullPayload: any);
        get fullPayload(): any;
        buildForUndisclosedPayload(undisclosedSDPayload: any): id.walt.sdjwt.SDPayload;
        buildForSDMap(sdMap: any): id.walt.sdjwt.SDPayload;
    }
}
export declare namespace id.walt.sdjwt {
    class SimpleAsyncJWTCryptoProvider implements id.walt.sdjwt.JSAsyncJWTCryptoProvider {
        constructor(algorithm: string, keyParam: any, options: any);
        signAsync(payload: any, keyID: Nullable<string>): Promise<string>;
        verifyAsync(jwt: string): Promise<id.walt.sdjwt.JwtVerificationResult>;
        readonly __doNotUseOrImplementIt: id.walt.sdjwt.JSAsyncJWTCryptoProvider["__doNotUseOrImplementIt"];
    }
    namespace SimpleAsyncJWTCryptoProvider {
        class $signCOROUTINE$2 /* extends kotlin.coroutines.CoroutineImpl */ {
            constructor(_this_: id.walt.sdjwt.SimpleAsyncJWTCryptoProvider, payload: any/* kotlinx.serialization.json.JsonObject */, keyID: Nullable<string>, resultContinuation: any/* kotlin.coroutines.Continuation<string> */);
        }
        class $verifyCOROUTINE$3 /* extends kotlin.coroutines.CoroutineImpl */ {
            constructor(_this_: id.walt.sdjwt.SimpleAsyncJWTCryptoProvider, jwt: string, resultContinuation: any/* kotlin.coroutines.Continuation<id.walt.sdjwt.JwtVerificationResult> */);
        }
    }
}
export as namespace id_walt_waltid_sd_jwt;