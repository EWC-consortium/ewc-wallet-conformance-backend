(function (root, factory) {
  if (typeof define === 'function' && define.amd)
    define(['exports', './kotlin-kotlin-stdlib.js'], factory);
  else if (typeof exports === 'object')
    factory(module.exports, require('./kotlin-kotlin-stdlib.js'));
  else {
    if (typeof this['kotlin-kotlin-stdlib'] === 'undefined') {
      throw new Error("Error loading module 'cryptography-kotlin-cryptography-random'. Its dependency 'kotlin-kotlin-stdlib' was not found. Please, check whether 'kotlin-kotlin-stdlib' is loaded prior to 'cryptography-kotlin-cryptography-random'.");
    }
    root['cryptography-kotlin-cryptography-random'] = factory(typeof this['cryptography-kotlin-cryptography-random'] === 'undefined' ? {} : this['cryptography-kotlin-cryptography-random'], this['kotlin-kotlin-stdlib']);
  }
}(this, function (_, kotlin_kotlin) {
  'use strict';
  //region block: imports
  var imul = Math.imul;
  var protoOf = kotlin_kotlin.$_$.s7;
  var objectMeta = kotlin_kotlin.$_$.r7;
  var setMetadataFor = kotlin_kotlin.$_$.t7;
  var Random = kotlin_kotlin.$_$.y7;
  var classMeta = kotlin_kotlin.$_$.t6;
  var Unit_instance = kotlin_kotlin.$_$.o3;
  //endregion
  //region block: pre-declaration
  setMetadataFor(CryptographyRandom, 'CryptographyRandom', classMeta, Random);
  setMetadataFor(Default, 'Default', objectMeta, CryptographyRandom);
  setMetadataFor(PlatformRandom, 'PlatformRandom', classMeta, CryptographyRandom);
  setMetadataFor(WebCryptoCryptographyRandom, 'WebCryptoCryptographyRandom', objectMeta, PlatformRandom);
  //endregion
  function Default() {
    Default_instance = this;
    CryptographyRandom.call(this);
    this.bi_1 = defaultCryptographyRandom();
  }
  protoOf(Default).je = function (bitCount) {
    return this.bi_1.je(bitCount);
  };
  protoOf(Default).qd = function () {
    return this.bi_1.qd();
  };
  protoOf(Default).ke = function () {
    return this.bi_1.ke();
  };
  protoOf(Default).le = function (array) {
    return this.bi_1.le(array);
  };
  protoOf(Default).oe = function (size) {
    return this.bi_1.oe(size);
  };
  protoOf(Default).me = function (array, fromIndex, toIndex) {
    return this.bi_1.me(array, fromIndex, toIndex);
  };
  var Default_instance;
  function Default_getInstance() {
    if (Default_instance == null)
      new Default();
    return Default_instance;
  }
  function CryptographyRandom() {
    Default_getInstance();
    Random.call(this);
  }
  function PlatformRandom() {
    CryptographyRandom.call(this);
  }
  protoOf(PlatformRandom).je = function (bitCount) {
    var numBytes = (bitCount + 7 | 0) / 8 | 0;
    var b = this.oe(numBytes);
    var next = 0;
    var inductionVariable = 0;
    if (inductionVariable < numBytes)
      do {
        var i = inductionVariable;
        inductionVariable = inductionVariable + 1 | 0;
        next = (next << 8) + (b[i] & 255) | 0;
      }
       while (inductionVariable < numBytes);
    return next >>> (imul(numBytes, 8) - bitCount | 0) | 0;
  };
  protoOf(PlatformRandom).le = function (array) {
    // Inline function 'kotlin.collections.isNotEmpty' call
    // Inline function 'kotlin.collections.isEmpty' call
    if (!(array.length === 0)) {
      this.ci(array);
    }
    return array;
  };
  function defaultCryptographyRandom() {
    return WebCryptoCryptographyRandom_getInstance();
  }
  function getRandomValues($this, array) {
    $this.ei_1.getRandomValues(array);
  }
  function WebCryptoCryptographyRandom() {
    WebCryptoCryptographyRandom_instance = this;
    PlatformRandom.call(this);
    this.di_1 = 65536;
    var tmp = this;
    // Inline function 'kotlin.run' call
    // Inline function 'kotlin.contracts.contract' call
    // Inline function 'dev.whyoleg.cryptography.random.WebCryptoCryptographyRandom.crypto.<anonymous>' call
    // Inline function 'kotlin.js.unsafeCast' call
    var isNodeJs = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
    tmp.ei_1 = isNodeJs ? eval('require')('node:crypto').webcrypto : window ? window.crypto ? window.crypto : window.msCrypto : self.crypto;
  }
  protoOf(WebCryptoCryptographyRandom).ci = function (array) {
    var size = array.length;
    // Inline function 'kotlin.js.unsafeCast' call
    // Inline function 'kotlin.js.asDynamic' call
    var jsArray = array;
    if (size <= 65536)
      return getRandomValues(this, jsArray);
    var filled = 0;
    do {
      // Inline function 'kotlin.comparisons.minOf' call
      var b = size - filled | 0;
      var chunkSize = Math.min(65536, b);
      getRandomValues(this, jsArray.subarray(filled, filled + chunkSize | 0));
      filled = filled + chunkSize | 0;
    }
     while (filled < size);
  };
  var WebCryptoCryptographyRandom_instance;
  function WebCryptoCryptographyRandom_getInstance() {
    if (WebCryptoCryptographyRandom_instance == null)
      new WebCryptoCryptographyRandom();
    return WebCryptoCryptographyRandom_instance;
  }
  //region block: exports
  _.$_$ = _.$_$ || {};
  _.$_$.a = Default_getInstance;
  //endregion
  return _;
}));

//# sourceMappingURL=cryptography-kotlin-cryptography-random.js.map
