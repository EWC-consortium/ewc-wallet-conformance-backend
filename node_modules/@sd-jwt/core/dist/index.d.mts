import * as _sd_jwt_types from '@sd-jwt/types';
import { Base64urlString, Signer, Verifier, kbHeader, kbPayload, KbVerifier, JwtPayload, SDJWTCompact, Hasher, PresentationFrame, DisclosureFrame, HasherAndAlg, SaltGenerator, SDJWTConfig, KBOptions } from '@sd-jwt/types';
import { Disclosure } from '@sd-jwt/utils';

type JwtData<Header extends Record<string, unknown>, Payload extends Record<string, unknown>> = {
    header?: Header;
    payload?: Payload;
    signature?: Base64urlString;
    encoded?: string;
};
declare class Jwt<Header extends Record<string, unknown> = Record<string, unknown>, Payload extends Record<string, unknown> = Record<string, unknown>> {
    header?: Header;
    payload?: Payload;
    signature?: Base64urlString;
    private encoded?;
    constructor(data?: JwtData<Header, Payload>);
    static decodeJWT<Header extends Record<string, unknown> = Record<string, unknown>, Payload extends Record<string, unknown> = Record<string, unknown>>(jwt: string): {
        header: Header;
        payload: Payload;
        signature: Base64urlString;
    };
    static fromEncode<Header extends Record<string, unknown> = Record<string, unknown>, Payload extends Record<string, unknown> = Record<string, unknown>>(encodedJwt: string): Jwt<Header, Payload>;
    setHeader(header: Header): Jwt<Header, Payload>;
    setPayload(payload: Payload): Jwt<Header, Payload>;
    protected getUnsignedToken(): string;
    sign(signer: Signer): Promise<string>;
    encodeJwt(): string;
    verify(verifier: Verifier): Promise<{
        payload: Payload | undefined;
        header: Header | undefined;
    }>;
}

declare class KBJwt<Header extends kbHeader = kbHeader, Payload extends kbPayload = kbPayload> extends Jwt<Header, Payload> {
    verifyKB(values: {
        verifier: KbVerifier;
        payload: JwtPayload;
    }): Promise<{
        payload: Payload;
        header: Header;
    }>;
    static fromKBEncode<Header extends kbHeader = kbHeader, Payload extends kbPayload = kbPayload>(encodedJwt: string): KBJwt<Header, Payload>;
}

type SDJwtData<Header extends Record<string, unknown>, Payload extends Record<string, unknown>, KBHeader extends kbHeader = kbHeader, KBPayload extends kbPayload = kbPayload> = {
    jwt?: Jwt<Header, Payload>;
    disclosures?: Array<Disclosure>;
    kbJwt?: KBJwt<KBHeader, KBPayload>;
};
declare class SDJwt<Header extends Record<string, unknown> = Record<string, unknown>, Payload extends Record<string, unknown> = Record<string, unknown>, KBHeader extends kbHeader = kbHeader, KBPayload extends kbPayload = kbPayload> {
    jwt?: Jwt<Header, Payload>;
    disclosures?: Array<Disclosure>;
    kbJwt?: KBJwt<KBHeader, KBPayload>;
    constructor(data?: SDJwtData<Header, Payload, KBHeader, KBPayload>);
    static decodeSDJwt<Header extends Record<string, unknown> = Record<string, unknown>, Payload extends Record<string, unknown> = Record<string, unknown>, KBHeader extends kbHeader = kbHeader, KBPayload extends kbPayload = kbPayload>(sdjwt: SDJWTCompact, hasher: Hasher): Promise<{
        jwt: Jwt<Header, Payload>;
        disclosures: Array<Disclosure>;
        kbJwt?: KBJwt<KBHeader, KBPayload>;
    }>;
    static fromEncode<Header extends Record<string, unknown> = Record<string, unknown>, Payload extends Record<string, unknown> = Record<string, unknown>, KBHeader extends kbHeader = kbHeader, KBPayload extends kbPayload = kbPayload>(encodedSdJwt: SDJWTCompact, hasher: Hasher): Promise<SDJwt<Header, Payload>>;
    present<T extends Record<string, unknown>>(presentFrame: PresentationFrame<T> | undefined, hasher: Hasher): Promise<SDJWTCompact>;
    encodeSDJwt(): SDJWTCompact;
    keys(hasher: Hasher): Promise<string[]>;
    presentableKeys(hasher: Hasher): Promise<string[]>;
    getClaims<T>(hasher: Hasher): Promise<T>;
}
declare const listKeys: (obj: Record<string, unknown>, prefix?: string) => string[];
declare const pack: <T extends Record<string, unknown>>(claims: T, disclosureFrame: DisclosureFrame<T> | undefined, hash: HasherAndAlg, saltGenerator: SaltGenerator) => Promise<{
    packedClaims: Record<string, unknown> | Array<Record<string, unknown>>;
    disclosures: Array<Disclosure>;
}>;

declare const createDecoy: (hash: HasherAndAlg, saltGenerator: SaltGenerator) => Promise<string>;

type SdJwtPayload = Record<string, unknown>;
declare class SDJwtInstance<ExtendedPayload extends SdJwtPayload> {
    protected type?: string;
    static DEFAULT_hashAlg: string;
    private userConfig;
    constructor(userConfig?: SDJWTConfig);
    private createKBJwt;
    private SignJwt;
    private VerifyJwt;
    issue<Payload extends ExtendedPayload>(payload: Payload, disclosureFrame?: DisclosureFrame<Payload>, options?: {
        header?: object;
    }): Promise<SDJWTCompact>;
    /**
     * Validates if the disclosureFrame contains any reserved fields. If so it will throw an error.
     * @param disclosureFrame
     * @returns
     */
    protected validateReservedFields<T extends ExtendedPayload>(disclosureFrame: DisclosureFrame<T>): void;
    present<T extends Record<string, unknown>>(encodedSDJwt: string, presentationFrame?: PresentationFrame<T>, options?: {
        kb?: KBOptions;
    }): Promise<SDJWTCompact>;
    verify(encodedSDJwt: string, requiredClaimKeys?: string[], requireKeyBindings?: boolean): Promise<{
        payload: unknown;
        header: Record<string, unknown> | undefined;
        kb?: undefined;
    } | {
        payload: unknown;
        header: Record<string, unknown> | undefined;
        kb: {
            payload: _sd_jwt_types.kbPayload;
            header: _sd_jwt_types.kbHeader;
        };
    }>;
    private calculateSDHash;
    validate(encodedSDJwt: string): Promise<{
        payload: unknown;
        header: Record<string, unknown> | undefined;
    }>;
    config(newConfig: SDJWTConfig): void;
    encode(sdJwt: SDJwt): SDJWTCompact;
    decode(endcodedSDJwt: SDJWTCompact): Promise<SDJwt<Record<string, unknown>, Record<string, unknown>, _sd_jwt_types.kbHeader, _sd_jwt_types.kbPayload>>;
    keys(endcodedSDJwt: SDJWTCompact): Promise<string[]>;
    presentableKeys(endcodedSDJwt: SDJWTCompact): Promise<string[]>;
    getClaims(endcodedSDJwt: SDJWTCompact): Promise<unknown>;
}

export { Jwt, type JwtData, KBJwt, SDJwt, type SDJwtData, SDJwtInstance, type SdJwtPayload, createDecoy, listKeys, pack };
